# 🫀 控制器心跳协议

本文档定义了多控制器环境下的 **CAN 总线心跳协议**，用于控制器间的存活检测，避免多个控制器同时控制车辆。

---

## 一、协议概述

| 目标 | 说明 |
|------|------|
| **防止控制冲突** | 确保同一时刻只有一个控制器发送电机控制命令 |
| **简单可靠** | 心跳与速度命令同步发送，其他控制器检测到心跳后让出控制权 |

---

## 二、心跳帧格式

### 2.1 基本配置

| 参数 | 值 | 说明 |
|------|-----|------|
| **帧类型** | 扩展帧（29-bit ID） | 与电机驱动器协议一致 |
| **心跳帧 ID** | `0x1800001` | A 控制器心跳 ID |
| **数据长度** | 8 字节 | 固定长度 |
| **发送周期** | 100 ms | 与电机控制任务周期一致 |
| **发送频率** | 10 Hz | 每秒发送 10 次心跳 |
| **超时阈值** | 200 ms | 连续 2 次未收到心跳则判定离线 |
| **CAN 波特率** | 250 Kbps | 与电机驱动器一致 |

### 2.2 CAN 总线流量

| 指标 | 值 | 说明 |
|------|-----|------|
| **每周期 CAN 帧数** | 5 帧 | 1心跳 + 2使能 + 2速度 |
| **每秒 CAN 帧数** | 50 帧 | 10Hz × 5帧 |
| **心跳帧间隔** | 100 ms | 固定周期 |

### 2.2 数据帧结构

```
字节位置:  [0]      [1]      [2]      [3]      [4]      [5]      [6]      [7]
数据内容:  CTRL_ID  STATUS   SEQ_H    SEQ_L    SPD_A_H  SPD_A_L  SPD_B_H  SPD_B_L
```

| 字节 | 名称 | 说明 |
|------|------|------|
| **Byte 0** | `CTRL_ID` | 控制器 ID（0x01 = A控制器） |
| **Byte 1** | `STATUS` | 状态：`0x01` = 正常控车中 |
| **Byte 2-3** | `SEQ` | 心跳序列号（16位递增） |
| **Byte 4-5** | `SPD_A` | A 路电机目标速度（-10000~+10000） |
| **Byte 6-7** | `SPD_B` | B 路电机目标速度（-10000~+10000） |

---

## 三、发送示例

### 3.1 发送代码

```c
// 每个控制周期执行
void control_cycle(void) {
    // 1. 先发送心跳帧
    send_heartbeat(0x01, 0x01, target_speed_a, target_speed_b);
    
    // 2. 再发送电机速度命令
    send_motor_speed(MOTOR_A, target_speed_a);
    send_motor_speed(MOTOR_B, target_speed_b);
}
```

### 3.2 报文示例

```text
帧 ID:   0x1800001
数据:    01 01 00 2A 03 E8 03 E8
         │  │  └─┬─┘ └─┬─┘ └─┬─┘
         │  │    │     │     └── B路速度: 1000
         │  │    │     └──────── A路速度: 1000
         │  │    └────────────── 序列号: 42
         │  └─────────────────── 状态: 0x01 正常控车中
         └────────────────────── 控制器ID: 0x01
```

---

## 四、接收方处理

### 4.1 处理逻辑

```c
#define HEARTBEAT_TIMEOUT_MS    200  // 超时阈值：2个心跳周期
#define HEARTBEAT_FRAME_ID      0x1800001

static uint32_t last_heartbeat_time = 0;
static bool other_controller_active = false;

// 心跳接收
void on_heartbeat_received(can_frame_t *frame) {
    if (frame->id == HEARTBEAT_FRAME_ID) {
        other_controller_active = true;
        last_heartbeat_time = get_current_time_ms();
    }
}

// 超时检测
void heartbeat_check(void) {
    if (other_controller_active) {
        if (get_current_time_ms() - last_heartbeat_time > HEARTBEAT_TIMEOUT_MS) {
            other_controller_active = false;
        }
    }
}

// 是否允许控车
bool can_i_control(void) {
    return !other_controller_active;
}
```

### 4.2 控制规则

| 条件 | 动作 |
|------|------|
| 收到心跳 | **禁止控车**，让出控制权 |
| 心跳超时（>200ms） | **允许控车**，可接管 |

---

## 五、注意事项

1. **心跳必须与速度命令同步发送**（每 100ms 发送一次）
2. **超时阈值设为 200ms**（2 个心跳周期），避免单次丢包误判
3. **CAN 波特率 250 Kbps**（与电机驱动器一致）