# ğŸ” è°ƒè¯•æ–¹æ³•æŒ‡å—

æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»ESP32æ§åˆ¶æ¿é¡¹ç›®çš„è°ƒè¯•æ–¹æ³•å’ŒæŠ€å·§ï¼ŒåŒ…æ‹¬æ—¥å¿—è°ƒè¯•ã€GDBè°ƒè¯•ã€æ€§èƒ½åˆ†æå’Œé—®é¢˜å®šä½ã€‚

## ğŸ¯ è°ƒè¯•ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—åï¼Œæ‚¨å°†æŒæ¡ï¼š
- âœ… æ—¥å¿—ç³»ç»Ÿçš„ä½¿ç”¨å’Œé…ç½®
- âœ… GDBè°ƒè¯•å™¨çš„æ“ä½œæ–¹æ³•
- âœ… æ€§èƒ½ç›‘æ§å’Œåˆ†ææŠ€å·§
- âœ… å¸¸è§é—®é¢˜çš„å®šä½å’Œè§£å†³

## ğŸ“Š è°ƒè¯•æ–¹æ³•åˆ†ç±»

### 1. æ—¥å¿—è°ƒè¯•ï¼ˆæ¨èï¼‰
- **ä¼˜ç‚¹**: ç®€å•æ˜“ç”¨ï¼Œå®æ—¶è¾“å‡º
- **é€‚ç”¨**: åŠŸèƒ½éªŒè¯ï¼ŒçŠ¶æ€ç›‘æ§
- **å·¥å…·**: ESP-IDF Monitor

### 2. æ–­ç‚¹è°ƒè¯•
- **ä¼˜ç‚¹**: ç²¾ç¡®æ§åˆ¶ï¼Œå˜é‡æŸ¥çœ‹
- **é€‚ç”¨**: é€»è¾‘é”™è¯¯ï¼Œç®—æ³•éªŒè¯
- **å·¥å…·**: GDBè°ƒè¯•å™¨

### 3. æ€§èƒ½åˆ†æ
- **ä¼˜ç‚¹**: ç³»ç»Ÿä¼˜åŒ–ï¼Œèµ„æºç›‘æ§
- **é€‚ç”¨**: æ€§èƒ½è°ƒä¼˜ï¼Œå†…å­˜åˆ†æ
- **å·¥å…·**: å†…ç½®åˆ†æå·¥å…·

## ğŸ”§ æ—¥å¿—è°ƒè¯•ç³»ç»Ÿ

### æ—¥å¿—çº§åˆ«é…ç½®

<augment_code_snippet path="main/log_config.c" mode="EXCERPT">
````c
/**
 * é…ç½®ç³»ç»Ÿæ—¥å¿—çº§åˆ«
 */
void configure_logging(void)
{
    // å…¨å±€æ—¥å¿—çº§åˆ«è®¾ç½®
    esp_log_level_set("*", ESP_LOG_INFO);
    
    // æ¨¡å—ç‰¹å®šæ—¥å¿—çº§åˆ«
    esp_log_level_set("SBUS", ESP_LOG_DEBUG);
    esp_log_level_set("CAN", ESP_LOG_DEBUG);
    esp_log_level_set("WIFI", ESP_LOG_INFO);
    esp_log_level_set("HTTP", ESP_LOG_WARN);
    esp_log_level_set("OTA", ESP_LOG_INFO);
    
    ESP_LOGI("LOG_CONFIG", "âœ… æ—¥å¿—ç³»ç»Ÿé…ç½®å®Œæˆ");
}
````
</augment_code_snippet>

### æ—¥å¿—è¾“å‡ºæŠ€å·§

```c
// æ¨¡å—ä¸“ç”¨æ—¥å¿—æ ‡ç­¾
static const char *TAG = "MODULE_NAME";

// åˆ†çº§æ—¥å¿—è¾“å‡º
ESP_LOGE(TAG, "âŒ Critical error: %s", esp_err_to_name(err));
ESP_LOGW(TAG, "âš ï¸ Warning: value=%d", value);
ESP_LOGI(TAG, "â„¹ï¸ Info: %s initialized", module_name);
ESP_LOGD(TAG, "ğŸ” Debug: data=0x%02X", data);

// æ¡ä»¶æ—¥å¿—è¾“å‡º
#if CONFIG_LOG_MAXIMUM_LEVEL >= ESP_LOG_DEBUG
    ESP_LOGD(TAG, "Debug info: %d", debug_value);
#endif

// æ ¼å¼åŒ–è¾“å‡º
ESP_LOGI(TAG, "ğŸ“Š Status: CPU=%d%%, MEM=%dKB, TEMP=%dÂ°C", 
         cpu_usage, mem_usage, temperature);
```

### æ—¥å¿—è¿‡æ»¤å’Œæœç´¢

```bash
# å¯åŠ¨ç›‘æ§å¹¶è¿‡æ»¤
idf.py -p COM10 monitor | grep "ERROR\|WARN"

# ä¿å­˜æ—¥å¿—åˆ°æ–‡ä»¶
idf.py -p COM10 monitor > debug.log 2>&1

# å®æ—¶æŸ¥çœ‹ç‰¹å®šæ¨¡å—æ—¥å¿—
idf.py -p COM10 monitor | grep "SBUS"

# æ—¶é—´æˆ³è¿‡æ»¤
idf.py -p COM10 monitor | grep "$(date +%H:%M)"
```

## ğŸ› GDBè°ƒè¯•å™¨ä½¿ç”¨

### å¯åŠ¨GDBè°ƒè¯•

```bash
# ç¼–è¯‘è°ƒè¯•ç‰ˆæœ¬
idf.py menuconfig  # é€‰æ‹© "Debug (-Og)"
idf.py build

# çƒ§å½•å¹¶å¯åŠ¨GDB
idf.py -p COM10 flash
idf.py gdb

# æˆ–è€…ä¸€æ­¥å®Œæˆ
idf.py -p COM10 flash gdb
```

### GDBåŸºæœ¬å‘½ä»¤

```gdb
# è¿æ¥ç›®æ ‡
(gdb) target remote :3333

# è®¾ç½®æ–­ç‚¹
(gdb) break main.c:100
(gdb) break sbus_init
(gdb) break *0x400d1234

# è¿è¡Œæ§åˆ¶
(gdb) continue
(gdb) step
(gdb) next
(gdb) finish

# æŸ¥çœ‹å˜é‡
(gdb) print variable_name
(gdb) print *pointer_var
(gdb) print array[0]@10

# æŸ¥çœ‹å†…å­˜
(gdb) x/10x 0x3ffb0000
(gdb) x/s string_ptr

# æŸ¥çœ‹è°ƒç”¨æ ˆ
(gdb) backtrace
(gdb) frame 2
(gdb) info locals
```

### é«˜çº§è°ƒè¯•æŠ€å·§

```gdb
# æ¡ä»¶æ–­ç‚¹
(gdb) break sbus.c:150 if channel[0] > 1800

# è§‚å¯Ÿç‚¹
(gdb) watch global_variable
(gdb) rwatch read_only_var

# æ–­ç‚¹å‘½ä»¤
(gdb) break main.c:200
(gdb) commands
> print "Reached checkpoint"
> continue
> end

# æŸ¥çœ‹ä»»åŠ¡ä¿¡æ¯
(gdb) info threads
(gdb) thread 2
(gdb) bt
```

## ğŸ“ˆ æ€§èƒ½ç›‘æ§å’Œåˆ†æ

### ç³»ç»Ÿèµ„æºç›‘æ§

```c
/**
 * ç³»ç»ŸçŠ¶æ€ç›‘æ§ä»»åŠ¡
 */
static void system_monitor_task(void *pvParameters)
{
    while (1) {
        // CPUä½¿ç”¨ç‡ï¼ˆéœ€è¦å¯ç”¨ç»Ÿè®¡åŠŸèƒ½ï¼‰
        #if configGENERATE_RUN_TIME_STATS
        char stats_buffer[1024];
        vTaskGetRunTimeStats(stats_buffer);
        ESP_LOGI(TAG, "ğŸ“Š CPU Stats:\n%s", stats_buffer);
        #endif
        
        // å†…å­˜ä½¿ç”¨æƒ…å†µ
        ESP_LOGI(TAG, "ğŸ’¾ Free heap: %d bytes", esp_get_free_heap_size());
        ESP_LOGI(TAG, "ğŸ’¾ Min free heap: %d bytes", esp_get_minimum_free_heap_size());
        ESP_LOGI(TAG, "ğŸ’¾ Largest free block: %d bytes", 
                heap_caps_get_largest_free_block(MALLOC_CAP_8BIT));
        
        // ä»»åŠ¡æ ˆä½¿ç”¨æƒ…å†µ
        ESP_LOGI(TAG, "ğŸ“š SBUS task stack: %d bytes free", 
                uxTaskGetStackHighWaterMark(sbus_task_handle));
        ESP_LOGI(TAG, "ğŸ“š Motor task stack: %d bytes free", 
                uxTaskGetStackHighWaterMark(control_task_handle));
        
        vTaskDelay(pdMS_TO_TICKS(10000)); // 10ç§’ç›‘æ§ä¸€æ¬¡
    }
}
```

### å†…å­˜æ³„æ¼æ£€æµ‹

```c
// å¯ç”¨å †å†…å­˜è·Ÿè¸ª
#include "esp_heap_trace.h"

void start_heap_trace(void)
{
    #if CONFIG_HEAP_TRACING
    static heap_trace_record_t trace_records[100];
    ESP_ERROR_CHECK(heap_trace_init_standalone(trace_records, 100));
    ESP_ERROR_CHECK(heap_trace_start(HEAP_TRACE_LEAKS));
    ESP_LOGI(TAG, "ğŸ” Heap tracing started");
    #endif
}

void stop_heap_trace(void)
{
    #if CONFIG_HEAP_TRACING
    ESP_ERROR_CHECK(heap_trace_stop());
    heap_trace_dump();
    ESP_LOGI(TAG, "ğŸ” Heap tracing stopped");
    #endif
}
```

### æ—¶é—´æ€§èƒ½æµ‹é‡

```c
/**
 * å‡½æ•°æ‰§è¡Œæ—¶é—´æµ‹é‡
 */
void measure_function_time(void)
{
    uint64_t start_time = esp_timer_get_time();
    
    // æ‰§è¡Œè¢«æµ‹è¯•çš„å‡½æ•°
    sbus_parse_function();
    
    uint64_t end_time = esp_timer_get_time();
    uint64_t execution_time = end_time - start_time;
    
    ESP_LOGI(TAG, "â±ï¸ Function execution time: %lld Î¼s", execution_time);
    
    // æ€§èƒ½åŸºå‡†æ£€æŸ¥
    if (execution_time > 1000) { // è¶…è¿‡1ms
        ESP_LOGW(TAG, "âš ï¸ Performance warning: function too slow");
    }
}
```

## ğŸ” é—®é¢˜å®šä½æŠ€å·§

### 1. ç³»ç»Ÿå´©æºƒåˆ†æ

```bash
# æŸ¥çœ‹å´©æºƒä¿¡æ¯
idf.py -p COM10 monitor

# è§£æå´©æºƒå †æ ˆ
addr2line -pfiaC -e build/esp32controlboard.elf 0x400d1234

# ä½¿ç”¨GDBåˆ†æcore dump
idf.py coredump-info
idf.py coredump-debug
```

### 2. æ­»é”æ£€æµ‹

```c
// ä»»åŠ¡çŠ¶æ€ç›‘æ§
void check_task_deadlock(void)
{
    TaskStatus_t *task_array;
    UBaseType_t task_count;
    
    task_count = uxTaskGetNumberOfTasks();
    task_array = pvPortMalloc(task_count * sizeof(TaskStatus_t));
    
    if (task_array != NULL) {
        task_count = uxTaskGetSystemState(task_array, task_count, NULL);
        
        for (int i = 0; i < task_count; i++) {
            if (task_array[i].eCurrentState == eBlocked) {
                ESP_LOGW(TAG, "âš ï¸ Task %s is blocked", task_array[i].pcTaskName);
            }
        }
        
        vPortFree(task_array);
    }
}
```

### 3. é€šä¿¡é—®é¢˜è°ƒè¯•

```c
// SBUSæ•°æ®è´¨é‡ç›‘æ§
static uint32_t sbus_frame_count = 0;
static uint32_t sbus_error_count = 0;

void sbus_quality_monitor(void)
{
    static uint32_t last_check_time = 0;
    uint32_t current_time = xTaskGetTickCount();
    
    if (current_time - last_check_time > pdMS_TO_TICKS(5000)) {
        float success_rate = (float)(sbus_frame_count - sbus_error_count) / sbus_frame_count * 100;
        ESP_LOGI(TAG, "ğŸ“Š SBUS Quality: %.2f%% (%d/%d)", 
                success_rate, sbus_frame_count - sbus_error_count, sbus_frame_count);
        
        if (success_rate < 95.0) {
            ESP_LOGW(TAG, "âš ï¸ SBUS quality degraded");
        }
        
        last_check_time = current_time;
    }
}
```

## ğŸ› ï¸ è°ƒè¯•å·¥å…·é…ç½®

### VS Codeè°ƒè¯•é…ç½®

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "ESP32 Debug",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/build/esp32controlboard.elf",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "miDebuggerPath": "xtensa-esp32-elf-gdb",
            "miDebuggerServerAddress": "localhost:3333",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ]
        }
    ]
}
```

### ä¸²å£ç›‘æ§é…ç½®

```bash
# é…ç½®ç›‘æ§è¿‡æ»¤å™¨
export IDF_MONITOR_FILTERS="esp32_controlboard:I sbus:D can:D"

# é…ç½®æ³¢ç‰¹ç‡
export IDF_MONITOR_BAUD=115200

# å¯åŠ¨ç›‘æ§
idf.py monitor
```

## ğŸ“Š è°ƒè¯•æœ€ä½³å®è·µ

### 1. åˆ†å±‚è°ƒè¯•ç­–ç•¥
- **ç¡¬ä»¶å±‚**: ä½¿ç”¨ä¸‡ç”¨è¡¨ã€ç¤ºæ³¢å™¨æ£€æŸ¥ä¿¡å·
- **é©±åŠ¨å±‚**: ä½¿ç”¨æ—¥å¿—éªŒè¯é©±åŠ¨åŠŸèƒ½
- **åº”ç”¨å±‚**: ä½¿ç”¨æ–­ç‚¹è°ƒè¯•ä¸šåŠ¡é€»è¾‘

### 2. æ¸è¿›å¼è°ƒè¯•
- **æœ€å°ç³»ç»Ÿ**: å…ˆéªŒè¯åŸºæœ¬åŠŸèƒ½
- **é€æ­¥æ·»åŠ **: ä¸€æ¬¡æ·»åŠ ä¸€ä¸ªæ¨¡å—
- **å›å½’æµ‹è¯•**: ç¡®ä¿æ–°åŠŸèƒ½ä¸å½±å“å·²æœ‰åŠŸèƒ½

### 3. æ–‡æ¡£åŒ–è°ƒè¯•
- **è®°å½•é—®é¢˜**: è¯¦ç»†è®°å½•é—®é¢˜ç°è±¡
- **è®°å½•è§£å†³æ–¹æ¡ˆ**: å»ºç«‹é—®é¢˜è§£å†³çŸ¥è¯†åº“
- **åˆ†äº«ç»éªŒ**: å›¢é˜Ÿå†…éƒ¨åˆ†äº«è°ƒè¯•æŠ€å·§

## ğŸ”§ å¸¸è§è°ƒè¯•åœºæ™¯

### åœºæ™¯1: SBUSæ— æ•°æ®
```c
// è°ƒè¯•æ­¥éª¤
1. æ£€æŸ¥ç¡¬ä»¶è¿æ¥
2. éªŒè¯UARTé…ç½®
3. ç›‘æ§åŸå§‹æ•°æ®
4. æ£€æŸ¥ä¿¡å·åç›¸
5. éªŒè¯å¸§è§£æé€»è¾‘
```

### åœºæ™¯2: å†…å­˜ä¸è¶³
```c
// è°ƒè¯•æ­¥éª¤
1. ç›‘æ§å †å†…å­˜ä½¿ç”¨
2. æ£€æŸ¥æ ˆæº¢å‡º
3. æŸ¥æ‰¾å†…å­˜æ³„æ¼
4. ä¼˜åŒ–å†…å­˜åˆ†é…
5. è°ƒæ•´ä»»åŠ¡æ ˆå¤§å°
```

### åœºæ™¯3: å®æ—¶æ€§é—®é¢˜
```c
// è°ƒè¯•æ­¥éª¤
1. æµ‹é‡ä»»åŠ¡å“åº”æ—¶é—´
2. åˆ†æä»»åŠ¡ä¼˜å…ˆçº§
3. æ£€æŸ¥é˜»å¡æ“ä½œ
4. ä¼˜åŒ–ä¸­æ–­å¤„ç†
5. è°ƒæ•´è°ƒåº¦ç­–ç•¥
```

---

ğŸ’¡ **æç¤º**: è°ƒè¯•æ˜¯å¼€å‘è¿‡ç¨‹ä¸­çš„é‡è¦æŠ€èƒ½ï¼Œç†Ÿç»ƒæŒæ¡å„ç§è°ƒè¯•æ–¹æ³•å°†å¤§å¤§æé«˜å¼€å‘æ•ˆç‡å’Œä»£ç è´¨é‡ï¼

ğŸ”— **ç›¸å…³é“¾æ¥**:
- [ç¼–è¯‘çƒ§å½•æŒ‡å—](ç¼–è¯‘çƒ§å½•æŒ‡å—.md)
- [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](æ€§èƒ½ä¼˜åŒ–æŒ‡å—.md)
- [å¸¸è§é—®é¢˜è§£ç­”](../05-æ•…éšœæ’é™¤/å¸¸è§é—®é¢˜è§£ç­”.md)
