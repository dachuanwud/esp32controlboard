# 差速计算算法详解

**文档版本**: v1.0
**最后更新**: 2025-11-02
**适用模块**: `main/channel_parse.c`

---

## 📋 目录

1. [算法概述](#算法概述)
2. [差速控制原理](#差速控制原理)
3. [运动模式详解](#运动模式详解)
4. [差速计算公式](#差速计算公式)
5. [特殊模式](#特殊模式)
6. [代码实现分析](#代码实现分析)
7. [计算示例](#计算示例)
8. [控制模式总结](#控制模式总结)

---

## 算法概述

### 核心思想

履带车（或差速驱动车辆）通过**左右两个履带/轮子的速度差**来实现转向：

- **直线行驶**: 左右速度相同
- **转弯**: 一侧速度快，一侧速度慢
- **原地转向**: 一侧向前，一侧向后

### 输入输出

```
输入:
  - 通道2 (sp_fb): 前后分量 (-100 ~ +100)
  - 通道0 (sp_lr): 左右分量 (-100 ~ +100)

输出:
  - left_speed:  左电机速度 (-100 ~ +100)
  - right_speed: 右电机速度 (-100 ~ +100)
```

---

## 差速控制原理

### 履带车转向机制

```
┌─────────────────────────────────────┐
│         差速转弯原理图               │
└─────────────────────────────────────┘

前进+右转情况:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
           ↑ 前进方向
    ┌──────┼──────┐
    │      │      │
    │ [左] │ [右] │  左轮: 速度 = 50
    │  50  │  30  │  右轮: 速度 = 30 (减速)
    │      │      │
    └──────┼──────┘
          ││
        转弯半径

左侧速度快 → 车辆向右转
```

### 速度分解

遥控器的摇杆输入被分解为两个分量：

1. **前后分量 (sp_fb)**: 来自通道2，控制前进/后退
2. **左右分量 (sp_lr)**: 来自通道0，控制左右转向

这两个分量组合后，通过差速算法计算出左右电机的实际速度。

---

## 运动模式详解

### 模式1: 停止模式

**条件**: `sp_fb == 0 && sp_lr == 0`

```c
// 代码位置: main/channel_parse.c:164-170
if (sp_fb == 0) {
    if (sp_lr == 0) {
        // 停止
        left_speed = 0;
        right_speed = 0;
    }
}
```

**说明**:
- 两个摇杆都在中位
- 左右电机速度都为0
- 车辆静止

**示例**:
```
输入: sp_fb = 0, sp_lr = 0
输出: left_speed = 0, right_speed = 0
```

---

### 模式2: 原地转向模式

**条件**: `sp_fb == 0 && sp_lr != 0`

```c
// 代码位置: main/channel_parse.c:171-178
else {
    // 原地转向
    left_speed = sp_lr;
    right_speed = (-1) * sp_lr;
}
```

**说明**:
- 前后摇杆在中位，左右摇杆有输入
- 左右电机速度**大小相等，方向相反**
- 车辆原地旋转

**右转示例**:
```
输入: sp_fb = 0, sp_lr = +50
输出: left_speed = +50, right_speed = -50

效果: 左轮向前转，右轮向后转 → 车辆顺时针旋转
```

**左转示例**:
```
输入: sp_fb = 0, sp_lr = -50
输出: left_speed = -50, right_speed = +50

效果: 左轮向后转，右轮向前转 → 车辆逆时针旋转
```

---

### 模式3: 直线前进/后退模式

**条件**: `sp_fb != 0 && sp_lr == 0`

```c
// 代码位置: main/channel_parse.c:180-186
if (sp_lr == 0) {
    // 前进或后退
    left_speed = sp_fb;
    right_speed = sp_fb;
}
```

**说明**:
- 只有前后摇杆有输入，左右摇杆在中位
- 左右电机速度**完全相同**
- 车辆直线行驶

**前进示例**:
```
输入: sp_fb = +50, sp_lr = 0
输出: left_speed = +50, right_speed = +50

效果: 左右轮同速向前 → 车辆直线前进
```

**后退示例**:
```
输入: sp_fb = -50, sp_lr = 0
输出: left_speed = -50, right_speed = -50

效果: 左右轮同速向后 → 车辆直线后退
```

---

### 模式4: 差速右转模式

**条件**: `sp_fb != 0 && sp_lr > 0`

```c
// 代码位置: main/channel_parse.c:187-193
else if (sp_lr > 0) {
    // 差速右转
    left_speed = sp_fb;
    right_speed = cal_offset(sp_fb, sp_lr);
}
```

**说明**:
- 前后摇杆有输入，左右摇杆向右
- **左轮保持原速**，右轮减速
- 车辆在前进/后退的同时向右转弯

**前进+右转示例**:
```
输入: sp_fb = +50, sp_lr = +20
计算过程:
  left_speed = sp_fb = 50
  right_speed = cal_offset(50, 20)

cal_offset() 计算:
  abs(50) > abs(20) → 继续
  v1 > 0 → return abs(50) - abs(20) = 30

输出: left_speed = +50, right_speed = +30

效果: 左轮速度50，右轮速度30 → 车辆前进同时右转
```

**后退+右转示例**:
```
输入: sp_fb = -50, sp_lr = +20
计算过程:
  left_speed = sp_fb = -50
  right_speed = cal_offset(-50, 20)

cal_offset() 计算:
  abs(-50) > abs(20) → 继续
  v1 < 0 → return abs(20) - abs(-50) = -30

输出: left_speed = -50, right_speed = -30

效果: 左轮速度-50，右轮速度-30 → 车辆后退同时右转
```

---

### 模式5: 差速左转模式

**条件**: `sp_fb != 0 && sp_lr < 0`

```c
// 代码位置: main/channel_parse.c:194-201
else {
    // 差速左转
    left_speed = cal_offset(sp_fb, sp_lr);
    right_speed = sp_fb;
}
```

**说明**:
- 前后摇杆有输入，左右摇杆向左
- **右轮保持原速**，左轮减速
- 车辆在前进/后退的同时向左转弯

**前进+左转示例**:
```
输入: sp_fb = +50, sp_lr = -20
计算过程:
  left_speed = cal_offset(50, -20)
  right_speed = sp_fb = 50

cal_offset() 计算:
  abs(50) > abs(-20) → 继续
  v1 > 0 → return abs(50) - abs(-20) = 30

输出: left_speed = +30, right_speed = +50

效果: 左轮速度30，右轮速度50 → 车辆前进同时左转
```

**后退+左转示例**:
```
输入: sp_fb = -50, sp_lr = -20
计算过程:
  left_speed = cal_offset(-50, -20)
  right_speed = sp_fb = -50

cal_offset() 计算:
  abs(-50) > abs(-20) → 继续
  v1 < 0 → return abs(-20) - abs(-50) = -30

输出: left_speed = -30, right_speed = -50

效果: 左轮速度-30，右轮速度-50 → 车辆后退同时左转
```

---

## 差速计算公式

### cal_offset() 函数详解

```c
// 代码位置: main/channel_parse.c:83-95
static int8_t cal_offset(int8_t v1, int8_t v2)
{
    // 保护性检查: 如果转向分量大于前进分量，返回0
    if (abs(v1) < abs(v2)) {
        return 0;
    }

    // 根据前进方向确定速度符号
    if (v1 > 0) {
        // 前进: 减速侧速度 = 前进速度 - 转向速度
        return abs(v1) - abs(v2);
    } else {
        // 后退: 减速侧速度 = 转向速度 - 前进速度
        return abs(v2) - abs(v1);
    }
}
```

### 公式说明

#### 前进时 (v1 > 0)
```
减速侧速度 = |前进速度| - |转向速度|
```

**物理意义**:
- 前进速度是基础速度
- 转向速度是速度差
- 减速侧速度 = 基础速度 - 速度差

#### 后退时 (v1 < 0)
```
减速侧速度 = |转向速度| - |前进速度|
```

**物理意义**:
- 由于后退速度是负数，需要保持符号
- 减速侧速度仍然是较小的绝对值
- 但符号与前进速度一致

### 边界条件处理

```c
if (abs(v1) < abs(v2)) {
    return 0;
}
```

**说明**:
- 如果转向分量大于前进分量，减速侧速度设为0
- 防止速度计算异常
- 实际场景中，转向分量通常小于前进分量

---

## 特殊模式

### 模式A: 单手模式

**触发条件**: 通道6 = 1950 (最高值)

```c
// 代码位置: main/channel_parse.c:131-146
bool current_single_hand = (ch_val[6] == 1950);

if (current_single_hand) {
    sp_lr = chg_val(ch_val[3]); // 使用通道3代替通道0
}
```

**说明**:
- 单手操作时，使用**通道3**代替通道0作为左右控制
- 允许单手同时控制前后和左右
- 适用于单手操作场景

**示例**:
```
正常模式:
  - 通道0: 左右控制
  - 通道2: 前后控制

单手模式 (通道6=1950):
  - 通道3: 左右控制 (代替通道0)
  - 通道2: 前后控制
```

---

### 模式B: 低速模式

**触发条件**: 通道7 = 1950 (最高值)

```c
// 代码位置: main/channel_parse.c:148-151
if (current_low_speed) {
    sp_fb /= 2;  // 前后速度减半
    sp_lr /= 2;  // 左右速度减半
}
```

**说明**:
- 速度减半，提供更精细的控制
- 适用于精确操作场景
- 前进和转向速度都减半

**示例**:
```
正常模式:
  输入: sp_fb = 50, sp_lr = 20
  输出: left_speed = 50, right_speed = 30

低速模式 (通道7=1950):
  输入: sp_fb = 50, sp_lr = 20
  处理后: sp_fb = 25, sp_lr = 10
  输出: left_speed = 25, right_speed = 15
```

---

## 代码实现分析

### 主控制函数流程

```c
// 代码位置: main/channel_parse.c:109-218
uint8_t parse_chan_val(uint16_t* ch_val)
{
    // 1. 提取前后和左右分量
    int8_t sp_fb = chg_val(ch_val[2]); // 通道2: 前后
    int8_t sp_lr = chg_val(ch_val[0]); // 通道0: 左右

    // 2. 检查特殊模式
    bool single_hand = (ch_val[6] == 1950);
    bool low_speed = (ch_val[7] == 1950);

    // 3. 应用特殊模式
    if (single_hand) {
        sp_lr = chg_val(ch_val[3]); // 使用通道3
    }
    if (low_speed) {
        sp_fb /= 2; // 速度减半
        sp_lr /= 2;
    }

    // 4. 差速计算 (5种模式)
    if (sp_fb == 0) {
        if (sp_lr == 0) {
            // 模式1: 停止
        } else {
            // 模式2: 原地转向
        }
    } else {
        if (sp_lr == 0) {
            // 模式3: 直线行驶
        } else if (sp_lr > 0) {
            // 模式4: 右转
        } else {
            // 模式5: 左转
        }
    }

    // 5. 执行电机控制
    intf_move(left_speed, right_speed);
}
```

### 决策树

```
                    sp_fb == 0?
                   /           \
                是/             \否
                /               \
        sp_lr == 0?          sp_lr == 0?
        /       \              /       \
      是/         \否         是/         \否
      /            \          /            \
   停止         原地转向   直线行驶    sp_lr > 0?
                                  /       \
                                是/         \否
                                /            \
                            右转           左转
```

---

## 计算示例

### 示例1: 前进+右转

```
输入参数:
  - 通道2 (前后): 1800 → sp_fb = +67
  - 通道0 (左右): 1650 → sp_lr = +33

计算过程:
  1. sp_fb = +67, sp_lr = +33
  2. 判断: sp_fb != 0 && sp_lr > 0 → 差速右转模式
  3. left_speed = sp_fb = 67
  4. right_speed = cal_offset(67, 33)
     - abs(67) > abs(33) → 继续
     - v1 > 0 → return abs(67) - abs(33) = 34
  5. right_speed = 34

结果:
  left_speed = 67
  right_speed = 34

效果: 车辆以67%速度前进，同时以33%转向分量右转
      左轮速度67，右轮速度34 → 形成速度差实现右转
```

### 示例2: 后退+左转（低速模式）

```
输入参数:
  - 通道2 (前后): 1200 → sp_fb = -67
  - 通道0 (左右): 1350 → sp_lr = -33
  - 通道7 (低速): 1950 → 低速模式开启

计算过程:
  1. sp_fb = -67, sp_lr = -33
  2. 低速模式: sp_fb = -67/2 = -33, sp_lr = -33/2 = -16
  3. 判断: sp_fb != 0 && sp_lr < 0 → 差速左转模式
  4. left_speed = cal_offset(-33, -16)
     - abs(-33) > abs(-16) → 继续
     - v1 < 0 → return abs(-16) - abs(-33) = -17
  5. left_speed = -17
  6. right_speed = sp_fb = -33

结果:
  left_speed = -17
  right_speed = -33

效果: 车辆以33%速度后退，同时以16%转向分量左转
      左轮速度-17，右轮速度-33 → 形成速度差实现左转
      低速模式使得控制更精细
```

### 示例3: 原地右转

```
输入参数:
  - 通道2 (前后): 1500 → sp_fb = 0
  - 通道0 (左右): 1650 → sp_lr = +33

计算过程:
  1. sp_fb = 0, sp_lr = +33
  2. 判断: sp_fb == 0 && sp_lr != 0 → 原地转向模式
  3. left_speed = sp_lr = 33
  4. right_speed = -sp_lr = -33

结果:
  left_speed = 33
  right_speed = -33

效果: 左轮向前转33%，右轮向后转33%
      车辆原地顺时针旋转，不产生位移
```

### 示例4: 直线前进

```
输入参数:
  - 通道2 (前后): 1800 → sp_fb = +67
  - 通道0 (左右): 1500 → sp_lr = 0

计算过程:
  1. sp_fb = +67, sp_lr = 0
  2. 判断: sp_fb != 0 && sp_lr == 0 → 直线行驶模式
  3. left_speed = sp_fb = 67
  4. right_speed = sp_fb = 67

结果:
  left_speed = 67
  right_speed = 67

效果: 左右轮同速向前，车辆直线前进
```

---

## 控制模式总结

### 模式汇总表

| 模式 | 条件 | 左轮速度 | 右轮速度 | 效果 |
|------|------|---------|---------|------|
| **停止** | sp_fb=0, sp_lr=0 | 0 | 0 | 车辆静止 |
| **原地转向** | sp_fb=0, sp_lr≠0 | sp_lr | -sp_lr | 原地旋转 |
| **直线行驶** | sp_fb≠0, sp_lr=0 | sp_fb | sp_fb | 直线前进/后退 |
| **差速右转** | sp_fb≠0, sp_lr>0 | sp_fb | cal_offset(sp_fb, sp_lr) | 前进/后退+右转 |
| **差速左转** | sp_fb≠0, sp_lr<0 | cal_offset(sp_fb, sp_lr) | sp_fb | 前进/后退+左转 |

### 速度范围

所有速度值范围：**-100 ~ +100**
- **正值**: 向前转动
- **负值**: 向后转动
- **0**: 停止

### 特殊模式组合

| 模式组合 | 说明 | 效果 |
|---------|------|------|
| **单手模式** | 通道6=1950 | 使用通道3代替通道0作为左右控制 |
| **低速模式** | 通道7=1950 | 前后和左右速度都减半 |
| **单手+低速** | 通道6=1950, 通道7=1950 | 同时应用两种模式 |

---

## 算法特点

### 优点

1. **平滑控制**: 差速算法提供平滑的转弯控制
2. **灵活组合**: 可以同时前进和转向
3. **精确操作**: 低速模式提供精细控制
4. **安全保护**: 边界条件检查防止异常

### 注意事项

1. **速度限制**: 所有速度值必须在 -100 ~ +100 范围内
2. **符号处理**: 后退时速度符号保持一致
3. **边界检查**: cal_offset() 函数防止转向分量过大
4. **模式切换**: 特殊模式在通道值变化时及时更新

---

## 可视化示意

### 速度矢量图

```
前进+右转 (sp_fb=50, sp_lr=20):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          前进方向 (sp_fb=50)
                ↑
                │
          ┌─────┼─────┐
          │     │     │
   左轮50 │  ↘  │  ↘  │ 右轮30
          │   ↙ │   ↙ │
          └─────┼─────┘
                │
                ↓
          转向分量 (sp_lr=20)

合成效果: 车辆向右前方移动
```

### 速度计算可视化

```
前进+右转计算:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

输入: sp_fb = 50, sp_lr = 20
      ↓
      ├─ 左轮速度计算
      │   left_speed = sp_fb = 50
      │
      └─ 右轮速度计算
          right_speed = cal_offset(50, 20)
                       = |50| - |20|
                       = 30

输出: left_speed = 50, right_speed = 30
      ↓
      速度差: 50 - 30 = 20 (转向分量)
      平均速度: (50 + 30) / 2 = 40 (前进速度)
```

---

## 相关代码位置

| 功能 | 函数名 | 文件位置 | 行号 |
|------|--------|---------|------|
| **主控制函数** | `parse_chan_val()` | `main/channel_parse.c` | 109-218 |
| **差速计算** | `cal_offset()` | `main/channel_parse.c` | 83-95 |
| **通道值映射** | `chg_val()` | `main/channel_parse.c` | 30-35 |
| **电机控制** | `intf_move_keyadouble()` | `main/drv_keyadouble.c` | 166-201 |

---

## 调试建议

### 1. 添加调试日志

```c
ESP_LOGI(TAG, "🎮 输入: sp_fb=%d, sp_lr=%d", sp_fb, sp_lr);
ESP_LOGI(TAG, "📊 输出: left=%d, right=%d", left_speed, right_speed);
ESP_LOGI(TAG, "🔄 模式: %s", mode_name);
```

### 2. 验证计算

```c
// 验证速度范围
assert(left_speed >= -100 && left_speed <= 100);
assert(right_speed >= -100 && right_speed <= 100);

// 验证模式逻辑
if (sp_fb == 0 && sp_lr == 0) {
    assert(left_speed == 0 && right_speed == 0);
}
```

### 3. 测试用例

| 测试场景 | sp_fb | sp_lr | 期望left | 期望right |
|---------|-------|-------|----------|-----------|
| 停止 | 0 | 0 | 0 | 0 |
| 前进 | 50 | 0 | 50 | 50 |
| 后退 | -50 | 0 | -50 | -50 |
| 原地右转 | 0 | 30 | 30 | -30 |
| 前进+右转 | 50 | 20 | 50 | 30 |
| 后退+左转 | -50 | -20 | -30 | -50 |

---

**文档结束**

如有问题或需要进一步解释，请参考代码实现或联系开发团队。
